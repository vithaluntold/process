# EPI-Q Platform - Security Penetration Testing Report
## Generated: November 14, 2025

---

## Executive Summary

This report presents the findings of a comprehensive security penetration test conducted on the EPI-Q enterprise process mining platform. The assessment evaluated authentication, authorization, injection vulnerabilities, API security, session management, and adherence to security best practices.

**Overall Security Posture: MODERATE** ‚ö†Ô∏è

While the platform implements several strong security controls (bcrypt hashing, ORM-based SQL injection prevention, JWT-based authentication, audit logging), **critical vulnerabilities were identified** that could allow Cross-Site Request Forgery (CSRF) attacks, session hijacking, and denial of service through missing rate limits.

---

## Vulnerability Summary

| Severity | Count | Description |
|----------|-------|-------------|
| üî¥ CRITICAL | 2 | CSRF protection missing on most endpoints, Missing secure cookie flags |
| üü† HIGH | 2 | No rate limiting on critical endpoints, JWT secret inconsistency |
| üü° MEDIUM | 3 | CSRF cookie accessible via JavaScript, In-memory rate limiting, No unique constraint on org emails |
| üîµ LOW | 2 | Session duration concerns, Missing security headers |
| ‚úÖ INFO | 8 | Strong password policies, ORM usage, Input validation, Audit logging |

---

## CRITICAL Vulnerabilities

### 1. Missing CSRF Protection on Most API Endpoints üî¥
**Severity:** CRITICAL  
**CVSS Score:** 8.8 (High)  
**CWE:** CWE-352 (Cross-Site Request Forgery)

**Description:**  
Out of 60+ POST/PUT/DELETE endpoints identified, only 4 endpoints implement CSRF token validation:
- `/api/auth/signup`
- `/api/gdpr/consent`
- `/api/gdpr/delete-account`

**Affected Endpoints (Sample):**
```
‚ùå /api/teams (POST) - No CSRF protection
‚ùå /api/processes (POST) - No CSRF protection  
‚ùå /api/invitations (POST) - No CSRF protection
‚ùå /api/organizations (POST, PUT, DELETE) - No CSRF protection
‚ùå /api/tickets (POST, PUT) - No CSRF protection
‚ùå /api/subscriptions (POST, PUT) - No CSRF protection
‚ùå /api/llm-providers (POST, PUT) - No CSRF protection
‚ùå /api/task-mining/* (POST, PUT, DELETE) - No CSRF protection
```

**Attack Scenario:**
```html
<!-- Attacker's malicious website -->
<form action="https://epiq.com/api/teams" method="POST" id="csrf">
  <input type="hidden" name="name" value="Hacker Team">
  <input type="hidden" name="managerId" value="1">
</form>
<script>
  document.getElementById('csrf').submit();
</script>
```
If an authenticated admin visits the attacker's site, a team is created without their knowledge.

**Impact:**  
- Unauthorized team/process/organization creation
- Account takeover through invitation abuse
- Subscription modification
- Data deletion
- Payment manipulation

**Proof of Concept:**
```bash
# Attacker can perform actions on behalf of authenticated users
curl -X POST https://epiq.com/api/teams \
  -H "Cookie: session=<stolen_or_user_session>" \
  -H "Content-Type: application/json" \
  -d '{"name":"Malicious Team","managerId":1}'
```

**Recommendation:**  
‚úÖ **Immediate Action Required:**
1. Add `requireCSRF()` check to ALL state-changing endpoints:
```typescript
import { requireCSRF } from "@/lib/csrf";

export async function POST(req: NextRequest) {
  const csrfError = requireCSRF(req);
  if (csrfError) return csrfError;
  // ... rest of endpoint logic
}
```

2. Update all POST/PUT/DELETE/PATCH endpoints in:
   - `/api/teams/*`
   - `/api/processes/*`
   - `/api/invitations/*`
   - `/api/organizations/*`
   - `/api/subscriptions/*`
   - `/api/tickets/*`
   - `/api/llm-providers/*`
   - `/api/task-mining/*`
   - All other mutation endpoints

---

### 2. Missing Secure Cookie Flag in Custom Login Route üî¥
**Severity:** CRITICAL  
**CVSS Score:** 7.5 (High)  
**CWE:** CWE-614 (Sensitive Cookie Without 'Secure' Attribute)

**Description:**  
The `/api/auth/login` endpoint sets the session cookie without the `secure` flag, allowing the cookie to be transmitted over unencrypted HTTP connections.

**Vulnerable Code:**
```typescript
// app/api/auth/login/route.ts (Line 106)
response.cookies.set("session", token, {
  httpOnly: true,
  sameSite: "lax",
  maxAge: 60 * 60 * 24 * 7,
  path: "/",
  // ‚ùå Missing: secure: true
});
```

**Impact:**  
- Session tokens transmitted over HTTP can be intercepted
- Man-in-the-middle (MITM) attacks can steal authentication tokens
- Session hijacking on insecure networks (public WiFi, compromised routers)

**Attack Scenario:**
```
1. User logs in from public WiFi
2. Attacker on same network intercepts HTTP traffic
3. Session cookie captured in plaintext
4. Attacker uses stolen session to impersonate user
```

**Recommendation:**  
‚úÖ **Immediate Fix:**
```typescript
response.cookies.set("session", token, {
  httpOnly: true,
  sameSite: "lax",
  secure: process.env.NODE_ENV === "production", // Add this
  maxAge: 60 * 60 * 24 * 7,
  path: "/",
});
```

Also verify the same pattern in:
- `/api/auth/logout/route.ts`
- `/api/auth/user/route.ts`
- `/lib/server-auth.ts`

---

## HIGH Vulnerabilities

### 3. Missing Rate Limiting on Critical Endpoints üü†
**Severity:** HIGH  
**CVSS Score:** 7.1 (High)  
**CWE:** CWE-770 (Allocation of Resources Without Limits)

**Description:**  
Only 2 endpoints implement rate limiting (`/api/auth/login` and `/api/auth/signup`). All other endpoints are vulnerable to:
- Brute force attacks
- Denial of Service (DoS)
- API abuse
- Resource exhaustion

**Unprotected Critical Endpoints:**
```
‚ùå /api/invitations/accept - No rate limiting (brute force invitation tokens)
‚ùå /api/processes/* - No rate limiting (resource exhaustion)
‚ùå /api/teams/* - No rate limiting (spam team creation)
‚ùå /api/tickets/* - No rate limiting (ticket spam)
‚ùå /api/organizations/* - No rate limiting (organization abuse)
‚ùå /api/ai-assistant - No rate limiting (LLM API cost abuse)
‚ùå /api/llm-providers/validate - No rate limiting (brute force API keys)
```

**Attack Scenarios:**

**Scenario 1: Invitation Token Brute Force**
```bash
for token in $(cat token_wordlist.txt); do
  curl -X POST https://epiq.com/api/invitations/accept \
    -d "{\"token\":\"$token\",\"password\":\"Password123!\"}"
done
```

**Scenario 2: API Cost Exploitation**
```bash
# Exhaust LLM API credits
while true; do
  curl -X POST https://epiq.com/api/ai-assistant \
    -H "Cookie: session=$VALID_SESSION" \
    -d '{"query":"Generate long analysis"}'
done
```

**Scenario 3: Resource Exhaustion**
```bash
# Create thousands of processes
for i in {1..10000}; do
  curl -X POST https://epiq.com/api/processes \
    -H "Cookie: session=$VALID_SESSION" \
    -d "{\"name\":\"Process $i\",\"source\":\"spam\"}"
done
```

**Impact:**  
- Financial loss through LLM API abuse
- Database resource exhaustion
- Service degradation for legitimate users
- Successful brute force attacks
- Infrastructure costs from spam data

**Recommendation:**  
‚úÖ **Implement rate limiting on ALL endpoints:**

1. Create endpoint-specific rate limit configurations:
```typescript
// lib/rate-limiter.ts
export const INVITATION_ACCEPT_LIMIT: RateLimitConfig = {
  maxAttempts: 5,
  windowMs: 60 * 60 * 1000, // 5 attempts per hour
};

export const API_GENERAL_LIMIT: RateLimitConfig = {
  maxAttempts: 100,
  windowMs: 15 * 60 * 1000, // 100 requests per 15 minutes
};

export const AI_ASSISTANT_LIMIT: RateLimitConfig = {
  maxAttempts: 20,
  windowMs: 60 * 60 * 1000, // 20 requests per hour
};
```

2. Apply to endpoints:
```typescript
export async function POST(req: NextRequest) {
  const clientId = getClientIdentifier(req);
  const rateLimit = checkRateLimit(`endpoint:${clientId}`, API_GENERAL_LIMIT);
  
  if (!rateLimit.allowed) {
    return NextResponse.json(
      { error: "Rate limit exceeded" },
      { status: 429 }
    );
  }
  // ... endpoint logic
}
```

3. **Production Enhancement:** Migrate from in-memory storage to Redis for distributed rate limiting.

---

### 4. Inconsistent JWT Secret Management üü†
**Severity:** HIGH  
**CVSS Score:** 6.8 (Medium)

**Description:**  
JWT_SECRET is defined in multiple files with inconsistent fallback mechanisms:

**Multiple Definitions Found:**
1. `server/auth-utils.ts` - Throws in production, warns in dev
2. `lib/server-auth.ts` - Silent fallback to weak default
3. `app/api/auth/login/route.ts` - Silent fallback to weak default  
4. `app/api/auth/logout/route.ts` - Silent fallback to weak default
5. `app/api/auth/user/route.ts` - Silent fallback to weak default

**Vulnerable Pattern:**
```typescript
// ‚ùå Multiple files still use this pattern
const JWT_SECRET = new TextEncoder().encode(
  process.env.SESSION_SECRET || "dev-secret-change-in-production"
);
```

**Impact:**  
- Different parts of the application may use different secrets
- Silent fallback to weak defaults in production
- JWT tokens may become invalid after deployment
- Confusion during debugging authentication issues

**Recommendation:**  
‚úÖ **Centralize JWT secret management:**

1. Create single source of truth:
```typescript
// lib/jwt-config.ts
const isProduction = process.env.NODE_ENV === "production";

if (isProduction && !process.env.SESSION_SECRET) {
  throw new Error("SESSION_SECRET is required in production");
}

if (!isProduction && !process.env.SESSION_SECRET) {
  console.warn("‚ö†Ô∏è  Using dev JWT secret. Set SESSION_SECRET in production!");
}

export const JWT_SECRET = new TextEncoder().encode(
  process.env.SESSION_SECRET || "dev-secret-DO-NOT-USE-IN-PRODUCTION"
);
```

2. Import from single source:
```typescript
import { JWT_SECRET } from "@/lib/jwt-config";
```

3. Update all files to use centralized config
4. Add deployment checklist to verify SESSION_SECRET is set

---

## MEDIUM Vulnerabilities

### 5. CSRF Token Accessible via JavaScript üü°
**Severity:** MEDIUM  
**CVSS Score:** 5.3 (Medium)  
**CWE:** CWE-1004 (Sensitive Cookie Without 'HttpOnly' Flag)

**Description:**  
The CSRF token cookie is set with `httpOnly: false`, making it accessible to client-side JavaScript.

**Vulnerable Code:**
```typescript
// lib/csrf.ts (Line 21)
response.cookies.set("csrf-token", csrfToken, {
  httpOnly: false, // ‚ùå Allows JavaScript access
  sameSite: "strict",
  maxAge: 60 * 60 * 24 * 7,
  path: "/",
});
```

**Impact:**  
- XSS vulnerabilities can steal CSRF tokens
- Malicious browser extensions can access tokens
- Reduced defense-in-depth

**Justification Analysis:**  
This appears intentional to allow client-side reading for AJAX requests. However, it increases attack surface.

**Recommendation:**  
‚úÖ **Consider alternative patterns:**

Option 1 (Recommended): Double-submit cookie pattern
```typescript
// Keep cookie httpOnly, pass token in meta tag
response.cookies.set("csrf-token", csrfToken, {
  httpOnly: true, // Change to true
  sameSite: "strict",
});
// Pass to client via meta tag or server-rendered prop
```

Option 2: Accept current risk if justified by architecture needs, but add CSP headers.

---

### 6. In-Memory Rate Limiting Not Production-Ready üü°
**Severity:** MEDIUM  
**CVSS Score:** 5.0 (Medium)

**Description:**  
Rate limiting uses in-memory `Map` storage which has limitations:

```typescript
// lib/rate-limiter.ts
const rateLimitStore = new Map<string, RateLimitEntry>();
```

**Limitations:**  
- ‚ùå Resets on application restart
- ‚ùå Doesn't work across multiple instances/containers
- ‚ùå No persistence
- ‚ùå Can be bypassed by load balancer rotation

**Impact:**  
- Rate limits can be bypassed in horizontal scaling
- Attackers can exhaust limits then trigger restart
- Inconsistent enforcement across pods/instances

**Recommendation:**  
‚úÖ **For Production Deployment:**

1. Use Redis for distributed rate limiting:
```typescript
import { Redis } from "ioredis";

const redis = new Redis(process.env.REDIS_URL);

export async function checkRateLimit(identifier: string, config: RateLimitConfig) {
  const key = `ratelimit:${identifier}`;
  const current = await redis.incr(key);
  
  if (current === 1) {
    await redis.expire(key, config.windowMs / 1000);
  }
  
  return {
    allowed: current <= config.maxAttempts,
    remaining: Math.max(0, config.maxAttempts - current),
    resetTime: Date.now() + config.windowMs
  };
}
```

2. Alternative: Use Cloudflare Rate Limiting or AWS WAF for edge-level protection

---

### 7. Missing Unique Constraint on Organization Email üü°
**Severity:** MEDIUM  
**CVSS Score:** 4.3 (Medium)

**Description:**  
The `users` table has a unique constraint on email globally, but doesn't enforce uniqueness within organizations. While invitation acceptance checks for duplicates, direct database operations could bypass this.

**Current Schema:**
```typescript
// shared/schema.ts
export const users = pgTable("users", {
  email: text("email").notNull().unique(), // Global unique, not org-scoped
  organizationId: integer("organization_id"),
  // ...
});
```

**Impact:**  
- Race conditions during concurrent user creation
- Migration scripts could create duplicates
- Direct database operations bypass application-level checks

**Recommendation:**  
‚úÖ **Add composite unique constraint:**
```typescript
export const users = pgTable("users", {
  email: text("email").notNull(),
  organizationId: integer("organization_id"),
  // ...
}, (table) => ({
  // Add this
  orgEmailIdx: unique("users_org_email_unique").on(table.organizationId, table.email),
}));
```

Then run `npm run db:push` to apply.

---

## LOW Severity Issues

### 8. Excessive Session Duration üîµ
**Severity:** LOW  
**CVSS Score:** 3.1 (Low)

**Findings:**
- Custom login: 7 days (`app/api/auth/login/route.ts`)
- NextAuth: 30 days (`lib/auth.ts`)

**Recommendation:**  
Consider reducing to 24 hours with refresh token mechanism for better security posture.

---

### 9. Missing Security Headers üîµ
**Severity:** LOW  
**CVSS Score:** 3.5 (Low)

**Missing Headers:**
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY`
- `Strict-Transport-Security`
- `Content-Security-Policy`

**Recommendation:**  
Add to Next.js config:
```typescript
// next.config.js
async headers() {
  return [
    {
      source: '/:path*',
      headers: [
        { key: 'X-Content-Type-Options', value: 'nosniff' },
        { key: 'X-Frame-Options', value: 'DENY' },
        { key: 'X-XSS-Protection', value: '1; mode=block' },
        { key: 'Strict-Transport-Security', value: 'max-age=31536000; includeSubDomains' },
      ],
    },
  ];
}
```

---

## Security Strengths ‚úÖ

The platform implements several excellent security practices:

### 1. Strong Password Hashing ‚úÖ
- Uses `bcrypt` with 10-12 rounds
- Timing-attack resistant comparison
- No plaintext password storage

### 2. SQL Injection Prevention ‚úÖ
- **Drizzle ORM** used throughout (parameterized queries)
- No raw SQL with string concatenation
- Input validation with Zod schemas

### 3. Robust Input Validation ‚úÖ
```typescript
// lib/validation.ts - Excellent validation rules
export const passwordSchema = z.string()
  .min(12, "Password must be at least 12 characters")
  .regex(/[A-Z]/, "Must contain uppercase")
  .regex(/[a-z]/, "Must contain lowercase")
  .regex(/[0-9]/, "Must contain number");
```

### 4. Comprehensive Audit Logging ‚úÖ
- All authentication events logged
- User actions tracked with IP/User-Agent
- Critical operations audited

### 5. Multi-Tenant Data Isolation ‚úÖ
```typescript
// Excellent organization validation
const [manager] = await db.select()
  .from(users)
  .where(and(
    eq(users.id, validatedData.managerId),
    eq(users.organizationId, currentUser.organizationId) // ‚úÖ Prevents cross-tenant access
  ));
```

### 6. Transaction Safety ‚úÖ
- Row-level locking with `FOR UPDATE`
- Atomic operations in invitation acceptance
- Proper rollback on errors

### 7. API Key Security ‚úÖ
```typescript
// server/crypto-utils.ts
// ‚úÖ Excellent: Uses scrypt for API key hashing
// ‚úÖ Timing-safe comparison
// ‚úÖ AES-256-GCM encryption for stored keys
```

### 8. Role-Based Access Control ‚úÖ
- Comprehensive RBAC in `server/rbac.ts`
- Team-based permissions
- Process ownership validation

---

## Test Results Summary

### Authentication Testing
| Test | Result | Notes |
|------|--------|-------|
| JWT manipulation | ‚úÖ PASS | Proper signature verification |
| Session fixation | ‚úÖ PASS | New session on login |
| Password brute force | ‚ö†Ô∏è PARTIAL | Rate limited on login only |
| Token expiration | ‚úÖ PASS | Proper expiration handling |

### Authorization Testing
| Test | Result | Notes |
|------|--------|-------|
| Horizontal privilege escalation | ‚úÖ PASS | Organization isolation works |
| Vertical privilege escalation | ‚úÖ PASS | Role checks enforced |
| Direct object reference | ‚úÖ PASS | ID validation present |
| Cross-tenant access | ‚úÖ PASS | Organization ID filtering |

### Injection Testing
| Test | Result | Notes |
|------|--------|-------|
| SQL injection | ‚úÖ PASS | Drizzle ORM prevents injection |
| XSS | ‚úÖ PASS | Input sanitization present |
| Command injection | ‚úÖ PASS | No shell execution with user input |
| NoSQL injection | N/A | PostgreSQL only |

### API Security Testing
| Test | Result | Notes |
|------|--------|-------|
| CSRF protection | ‚ùå FAIL | Missing on most endpoints |
| Rate limiting | ‚ö†Ô∏è PARTIAL | Only on auth endpoints |
| Input validation | ‚úÖ PASS | Zod schemas enforced |
| Error handling | ‚úÖ PASS | No sensitive data leaked |

---

## Priority Remediation Roadmap

### Immediate (Within 24 Hours) - Critical
1. ‚úÖ **Add CSRF protection** to all POST/PUT/DELETE endpoints
2. ‚úÖ **Add secure flag** to session cookies
3. ‚úÖ **Centralize JWT_SECRET** management

### Short-term (Within 1 Week) - High
4. ‚úÖ **Implement rate limiting** on all API endpoints
5. ‚úÖ **Add Redis** for distributed rate limiting (if deploying multiple instances)
6. ‚úÖ **Add security headers** to Next.js configuration

### Medium-term (Within 1 Month) - Medium/Low
7. ‚úÖ **Add unique constraint** on organization emails
8. ‚úÖ **Implement refresh tokens** for session management
9. ‚úÖ **Add CSP headers** for XSS protection
10. ‚úÖ **Security audit** of all 60+ API endpoints

---

## Compliance Considerations

### OWASP Top 10 2021 Coverage

| Risk | Status | Notes |
|------|--------|-------|
| A01 Broken Access Control | ‚ö†Ô∏è PARTIAL | RBAC strong, CSRF weak |
| A02 Cryptographic Failures | ‚úÖ GOOD | Bcrypt, proper encryption |
| A03 Injection | ‚úÖ GOOD | ORM prevents SQLi |
| A04 Insecure Design | ‚úÖ GOOD | Good architecture |
| A05 Security Misconfiguration | ‚ö†Ô∏è PARTIAL | Missing headers, CSRF |
| A06 Vulnerable Components | ‚ÑπÔ∏è INFO | Review npm audit regularly |
| A07 Authentication Failures | ‚ö†Ô∏è PARTIAL | Strong auth, weak rate limits |
| A08 Software/Data Integrity | ‚úÖ GOOD | Audit logging present |
| A09 Logging Failures | ‚úÖ GOOD | Comprehensive audit logs |
| A10 Server-Side Request Forgery | ‚úÖ GOOD | No SSRF vectors found |

### GDPR Compliance ‚úÖ
- ‚úÖ Data export endpoints present
- ‚úÖ Account deletion with cascade
- ‚úÖ Consent management implemented
- ‚úÖ Audit trails for compliance

---

## Conclusion

The EPI-Q platform demonstrates **strong foundational security** with excellent password handling, SQL injection prevention, and multi-tenant isolation. However, **critical gaps in CSRF protection and rate limiting** create significant risk vectors that must be addressed immediately before production deployment.

**Recommended Actions:**
1. Implement all CRITICAL fixes within 24 hours
2. Deploy HIGH priority fixes within 1 week  
3. Schedule penetration test revalidation after remediation
4. Establish ongoing security review process

**Risk Assessment:**  
Current: **MODERATE RISK** ‚ö†Ô∏è  
Post-Remediation: **LOW RISK** ‚úÖ (if critical fixes applied)

---

**Report Prepared By:** Replit Security Agent  
**Testing Methodology:** OWASP Testing Guide v4.2, Manual Code Review, Automated Scanning  
**Platform Version:** EPI-Q v1.0 (November 2025)  
**Next Review Date:** December 14, 2025 (30 days)
